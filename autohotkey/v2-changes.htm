<html dir="ltr"><head>
<title>V2的改动</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"></meta>
<style type="text/css">pre code {
  background: none;
  border: none;
  margin: 0;
  padding: 0;
}
</style>
<style type="text/css">.highlight {
  background: #ffffff;
}
.highlight .c {
  color: #999988;
  font-style: italic;
}
.highlight .err {
  color: #a61717;
  background-color: #e3d2d2;
}
.highlight .k {
  font-weight: bold;
}
.highlight .o {
  font-weight: bold;
}
.highlight .cm {
  color: #999988;
  font-style: italic;
}
.highlight .cp {
  color: #999999;
  font-weight: bold;
}
.highlight .c1 {
  color: #999988;
  font-style: italic;
}
.highlight .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
.highlight .gd {
  color: #000000;
  background-color: #ffdddd;
}
.highlight .gd .x {
  color: #000000;
  background-color: #ffaaaa;
}
.highlight .ge {
  font-style: italic;
}
.highlight .gr {
  color: #aa0000;
}
.highlight .gh {
  color: #999999;
}
.highlight .gi {
  color: #000000;
  background-color: #ddffdd;
}
.highlight .gi .x {
  color: #000000;
  background-color: #aaffaa;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
  font-weight: bold;
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .gt {
  color: #aa0000;
}
.highlight .kc {
  font-weight: bold;
}
.highlight .kd {
  font-weight: bold;
}
.highlight .kp {
  font-weight: bold;
}
.highlight .kr {
  font-weight: bold;
}
.highlight .kt {
  color: #445588;
  font-weight: bold;
}
.highlight .m {
  color: #009999;
}
.highlight .s {
  color: #d14;
}
.highlight .na {
  color: #008080;
}
.highlight .nb {
  color: #0086b3;
}
.highlight .nc {
  color: #445588;
  font-weight: bold;
}
.highlight .no {
  color: #008080;
}
.highlight .ni {
  color: #800080;
}
.highlight .ne {
  color: #990000;
  font-weight: bold;
}
.highlight .nf {
  color: #990000;
  font-weight: bold;
}
.highlight .nn {
  color: #555555;
}
.highlight .nt {
  color: #000080;
}
.highlight .nv {
  color: #008080;
}
.highlight .ow {
  font-weight: bold;
}
.highlight .w {
  color: #bbbbbb;
}
.highlight .mf {
  color: #009999;
}
.highlight .mh {
  color: #009999;
}
.highlight .mi {
  color: #009999;
}
.highlight .mo {
  color: #009999;
}
.highlight .sb {
  color: #d14;
}
.highlight .sc {
  color: #d14;
}
.highlight .sd {
  color: #d14;
}
.highlight .s2 {
  color: #d14;
}
.highlight .se {
  color: #d14;
}
.highlight .sh {
  color: #d14;
}
.highlight .si {
  color: #d14;
}
.highlight .sx {
  color: #d14;
}
.highlight .sr {
  color: #009926;
}
.highlight .s1 {
  color: #d14;
}
.highlight .ss {
  color: #990073;
}
.highlight .bp {
  color: #999999;
}
.highlight .vc {
  color: #008080;
}
.highlight .vg {
  color: #008080;
}
.highlight .vi {
  color: #008080;
}
.highlight .il {
  color: #009999;
}
.pl-c {
  color: #969896;
}
.pl-c1, .pl-mdh, .pl-mm, .pl-mp, .pl-mr, .pl-s1 .pl-v, .pl-s3, .pl-sc, .pl-sv {
  color: #0086b3;
}
.pl-e, .pl-en {
  color: #795da3;
}
.pl-s1 .pl-s2, .pl-smi, .pl-smp, .pl-stj, .pl-vo, .pl-vpf {
  color: #333;
}
.pl-ent {
  color: #63a35c;
}
.pl-k, .pl-s, .pl-st {
  color: #a71d5d;
}
.pl-pds, .pl-s1, .pl-s1 .pl-pse .pl-s2, .pl-sr, .pl-sr .pl-cce, .pl-sr .pl-sra, .pl-sr .pl-sre, .pl-src, .pl-v {
  color: #df5000;
}
.pl-id {
  color: #b52a1d;
}
.pl-ii {
  background-color: #b52a1d;
  color: #f8f8f8;
}
.pl-sr .pl-cce {
  color: #63a35c;
  font-weight: bold;
}
.pl-ml {
  color: #693a17;
}
.pl-mh, .pl-mh .pl-en, .pl-ms {
  color: #1d3e81;
  font-weight: bold;
}
.pl-mq {
  color: #008080;
}
.pl-mi {
  color: #333;
  font-style: italic;
}
.pl-mb {
  color: #333;
  font-weight: bold;
}
.pl-md, .pl-mdhf {
  background-color: #ffecec;
  color: #bd2c00;
}
.pl-mdht, .pl-mi1 {
  background-color: #eaffea;
  color: #55a532;
}
.pl-mdr {
  color: #795da3;
  font-weight: bold;
}
.pl-mo {
  color: #1d3e81;
}
.task-list {
  padding-left: 10px;
  margin-bottom: 0;
}
.task-list li {
  margin-left: 20px;
}
.task-list-item {
  list-style-type: none;
  padding-left: 10px;
}
.task-list-item label {
  font-weight: 400;
}
.task-list-item.enabled label {
  cursor: pointer;
}
.task-list-item+.task-list-item {
  margin-top: 3px;
}
.task-list-item-checkbox {
  display: inline-block;
  margin-left: -20px;
  margin-right: 3px;
  vertical-align: 1px;
}
</style>
<style type="text/css">html, body {
  margin: 0;
  padding: 0;
  height: 100%;
}
body {
  margin: 0 8px 0 8px;
  font-size: .875em;
  line-height: 1.75;
  background-color: #fefefe;
  padding-bottom: 3em;
}
html {
  font-family: Arial,sans-serif;
}
img {
  border: none;
}
img::selection {
  background: transparent;
}
img::-moz-selection {
  background: transparent;
}
a {
  text-decoration: none;
}
a:link, a:active {
  color: #4280ca;
}
a:visited {
  color: #aa00aa;
}
a:hover, a:focus {
  text-decoration: underline;
  color: #2a6496;
}
#ahklogo img {
  margin: 20px 0 20px 0;
}
input, select {
  border: 1px solid #ccc;
}
pre, code {
  border-right: solid 1px #c8c8c8;
  border-bottom: solid 1px #c8c8c8;
  background-color: #f6f6e8;
}
pre, .Syntax {
  font-family: Consolas,Courier New,monospace;
}
.Syntax {
  background-color: #ffffaa;
  border: solid 1px #e8e89a;
}
code, span.Syntax {
  font-family: Consolas,Courier New,monospace;
  padding: 0 1px;
}
pre {
  background-color: #f6f6e8;
  /* #F3F3FF */
  margin: 0.7em 1.5em 0.7em 1.5em;
  padding: 0.7em 0 0.7em 0.7em;
  white-space: pre-wrap;
  /* works in IE8 but apparently not CHM viewer */
  word-wrap: break-word;
  /* works in CHM viewer */
}
pre.Syntax {
  margin: 0 0 1.0em 0;
  padding: 12px 0 12px 4px;
  line-height: 150%;
}
/* used with .Syntax */
pre, pre.Short {
  line-height: 120%;
}
pre em, code em {
  color: #00a000;
  font-style: normal;
}
.NoIndent {
  margin-left: 0;
}
::selection {
  color: #fff;
  background: #6c7a95;
}
::-moz-selection {
  color: #fff;
  background: #6c7a95;
}
h1 {
  font-size: 2em;
  font-weight: bold;
  border-bottom-color: #ffffff;
  border-bottom-width: 2px;
  margin-top: 8px;
  color: #3f5770;
}
.navh1 {
  font-weight: normal;
  background-color: #606060;
  color: #fff;
  margin: 0px -8px 8px -8px;
  padding: 7px 8px 0px 8px;
  text-overflow: ellipsis;
  overflow: hidden;
  height: 43px;
  border-bottom: 1px solid #ccc;
  font-size: 1.5em;
  white-space: nowrap;
}
.navh1 a {
  color: #ccc !important;
}
h2 {
  color: #a04040;
}
h3 {
  color: #008800;
}
#headerbar {
  background-color: #606060;
  position: absolute;
  top: 108px;
  left: 0px;
  width: 100%;
  height: 50px;
  z-index: -1;
  border-bottom: 1px solid #ccc;
}
a:visited {
  color: #7847b2;
}
h2:first-child {
  margin-top: 0;
}
h4 {
  margin-bottom: 0;
  line-height: 1;
}
h1, h2, h3 {
  border-bottom: 1px solid #ddd;
}
/* table of command parameters */
table {
  margin-bottom: 1em;
}
table.info {
  border: solid 2px #c0c0c0;
  border-collapse: collapse;
  width: 100%;
}
table.info td {
  border: solid 1px #c0c0c0;
  padding: 0.3em 0.5em;
}
table.info th {
  background-color: #f6f6f6;
  padding: 0.3em 0.5em;
}
/* heading note / version number/requirement tag */
.headnote, h1 .ver, h2 .ver, h3 .ver {
  color: #808080;
  font-size: 65%;
  font-weight: normal;
  margin-left: 1em;
  vertical-align: text-middle;
}
h4 .headnote, h4 .ver {
  font-weight: normal;
}
.ver, a.ver {
  color: gray;
}
a.ver:hover, a.ver:focus {
  text-decoration: none;
}
.dull {
  color: gray;
}
.red {
  color: red;
}
/* used for highlight in various places */
.blue {
  color: blue;
}
/* emphasized note */
.note {
  border-left: 2px solid #99bb99;
  background-color: #e6ffe6;
  color: #005500;
  padding: .5em 1em;
}
.warning {
  border-left: 2px solid #ffa000;
  background-color: #fff8e6;
  color: #c05500;
  padding: .5em 1em;
}
/* styles for briefly documenting multiple methods on one page: */
.methodShort {
  border: solid thin #c0c0c0;
  padding: 0.5em;
  margin-bottom: 1em;
}
.methodShort h2 {
  margin-top: 0;
  color: black;
  border-bottom: 0px;
}
.methodShort table.info {
  border: none;
}
.methodShort table.info td {
  border: none;
  vertical-align: text-top;
}
.methodShort:target {
  /* non-essential, but helpful if it works */
  border-color: black;
}
/* sidebar */
ul.jqtree-tree {
  margin-left: 20px;
}
ul.jqtree-tree, ul.jqtree-tree ul.jqtree_common {
  list-style: none outside;
  margin-bottom: 0;
  padding: 0;
}
ul.jqtree-tree ul.jqtree_common {
  display: block;
  margin-left: 12px;
  margin-right: 0;
}
ul.jqtree-tree li {
  line-height: 1.5em;
  padding: .2em 0 .2em 0;
}
ul.jqtree-tree li.jqtree-closed>ul.jqtree_common {
  display: none;
}
ul.jqtree-tree li.jqtree_common {
  clear: both;
  list-style-type: none;
}
ul.jqtree-tree .jqtree-toggler {
  display: block;
  position: absolute;
  left: -1.5em;
  top: 30%;
  /* fix for ie7 */
  font-size: 10px;
  line-height: 12px;
  font-family: arial;
  /* fix for ie9 */
  border-bottom: none;
  color: #333;
}
ul.jqtree-tree .jqtree-toggler:hover {
  color: #000;
}
ul.jqtree-tree .jqtree-element {
  cursor: pointer;
}
ul.jqtree-tree .jqtree-title {
  vertical-align: middle;
}
ul.jqtree-tree li.jqtree-folder {
  margin-bottom: 4px;
}
ul.jqtree-tree li.jqtree-folder.jqtree-closed {
  margin-bottom: 1px;
}
ul.jqtree-tree li.jqtree-folder .jqtree-title {
  margin-left: 0;
}
ul.jqtree-tree .jqtree-toggler.jqtree-closed {
  background-position: 0 0;
}
ul.jqtree-tree .jqtree-element {
  width: 100%;
  /* todo: why is this in here? */
  /* ie7 fix; issue 41 */
  position: relative;
}
ul.jqtree-tree li.jqtree-selected>.jqtree-element {
  font-weight: bold;
  color: #dd4b39;
}
ul.jqtree-tree li>.jqtree-element:hover {
  background-color: #eee;
}
.main-content {
  width: 100%;
  min-height: 100%;
  height: auto !important;
  height: 100%;
}
#app-body {
  width: 100%;
}
#app-body .left-col {
  width: 231px;
  float: left;
}
#app-body .right-col {
  margin-left: 231px;
}
#main-content {
  padding-left: 13px;
  padding-right: 26px;
  min-height: 230px;
  max-width: 950px;
}
.right-col #main-content {
  border-left: 1px solid #e5e5e5;
}
/* Header */
.header {
  position: relative;
  background: #333;
  height: 67px;
  padding: 20px 25px;
  margin: 0 -8px 0 -8px;
  border-bottom: 1px solid #e5e5e5;
  z-index: 9999;
  white-space: nowrap;
}
.hdr-table {
  width: 100%;
  max-width: 1180px;
  height: 81px;
}
.hdr-table td {
  margin: 0;
  padding: 0;
}
.hdr-table .hdr-image, .hdr-table .hdr-image img {
  width: 217px;
}
.hdr-table .hdr-search {
  vertical-align: bottom;
  padding-bottom: 13px;
}
.hdr-table .hdr-search form {
  display: inline-block;
}
.hdr-table .hdr-search input {
  padding-left: 5px;
  font-size: 1em;
  height: 25px;
  font-family: Arial,sans-serif;
  width: 210px;
  vertical-align: middle;
  border: 1px solid #999;
  margin-left: 8px;
}
.hdr-table .hdr-search #search-btn {
  display: inline-block;
  height: 27px;
  line-height: 27px;
  width: 70px;
  color: #bbb;
  background: #606060;
  text-align: center;
  vertical-align: middle;
  border: 1px solid #808080;
  text-transform: uppercase;
  cursor: pointer;
  margin: 0px 10px;
}
.hdr-table .hdr-search #search-btn:hover, .hdr-table .hdr-language li:hover {
  color: #fff;
  background: #808080;
}
.hdr-table .hdr-language {
  vertical-align: bottom;
  text-align: right;
  padding-bottom: 13px;
}
.hdr-table .hdr-language ul {
  display: inline-block;
  padding: 0;
  margin: 0;
}
.hdr-table .hdr-language li {
  border: 1px solid #808080;
  background: #606060;
  color: #bbb;
  cursor: pointer;
  display: block;
  width: 100px;
  text-align: center;
  vertical-align: middle;
  height: 27px;
  line-height: 27px;
  position: relative;
  text-transform: uppercase;
}
.hdr-table .hdr-language .second {
  left: -1px;
  position: absolute;
  top: 28px;
  display: none;
}
.hdr-table .hdr-language .second li {
  text-transform: none;
}
/* Footer */
.footer {
  background: #333;
  color: #fff;
  line-height: 44px;
  margin: 0 -8px 0 -8px;
  padding: 0 26px;
}
.footer a {
  color: #ccc;
}
.float-clear {
  clear: both;
}
.nav {
  width: 242px;
  float: left;
  margin-top: -2px;
  margin-left: -10px;
  padding: 0;
  list-style: none;
  background-color: #808080;
  border-bottom: 1px solid #ccc;
  border-top: 1px solid #ccc;
}
.nav li {
  float: left;
  width: 50%;
  text-align: center;
  cursor: pointer;
}
.nav .selected {
  background-color: #bbb;
}
.nav .selected span {
  color: #000;
}
.nav li span {
  display: block;
  padding: 8px 15px;
  text-decoration: none;
  color: #fff;
  border-right: 1px solid #ccc;
  height: 35px;
  text-transform: uppercase;
  font-size: 1.5em;
}
.nav li span:hover {
  color: #000;
  background-color: #bbb;
}
#IndexEntry {
  width: 214px;
  font-size: 1em;
  font-family: helvetica,Arial,sans-serif;
}
#indexcontainer {
  width: 216px;
  font-size: 1em;
  font-family: helvetica,Arial,sans-serif;
  height: 100%;
}
/* command parameters */
dt {
  /* param name */
  color: #008800;
  margin-left: 0.5em;
}
dd {
  margin-left: 1.5em;
  padding-left: 1.0em;
  border-left: 0.3em solid #e0e0e0;
  margin-bottom: 1em;
}
dd>p:first-child {
  margin-top: 0.3em;
}
</style>
<link href="v2-changes_files/theme.css" rel="stylesheet" type="text/css" media="all"></link>
<style id="zoomLevel-styles"></style></head>
<body dir="ltr">
<h1 id="changes-from-v1-1-to-v2-0">1.1版到2.0版的改动</h1>
<h2 id="language">语法</h2>
<h3 id="legacy-syntax-removed">删除遗留语法</h3>
<p>删除字面量赋值： <code>var = value</code></p>
<p>删除<code>If Var =|&lt;&gt;|&lt;|&gt;|&lt;=|&gt;= Value</code>；这些现在被解释为表达式。</p>
<h3 id="variables">变量</h3>
<p>变量名不能以数字开头，并且不能包含以前允许的这些字符： <code>@ # $</code> 。只允许字母，数字，下划线和非ASCII字符。</p>
<p>控制流语句的名称，不能用作变量、函数、类或窗口组名称。包括If, Else, Loop, LoopFiles, LoopRead, LoopReg, LoopParse, For, While, Until, Break, Continue, Goto, Gosub, Return, Try, Catch, Finally以及Throw。这主要是为了检测错误，例如<code>if (ex) break</code> 。</p>
<p>变量名解析需要一个结束百分号，和V1一样（但不同于早期的 V2 alpha版）。</p>
<p>文本、输出变量参数和双引号字符串，不仅可以包含<code>%variables%</code> ，还可以包含在百分比符号之间的任意表达式。字符串和表达式可以嵌套到任何深度。 <code>%(%varname%)%</code>是有效写法，并将在字符串中执行两次变量名解析，或表达式中执行三次变量名解析。</p>
<p>双层变量解析，现在随载入时的变量解析一起进行。也就是说，仅当函数为假设全局模式，或函数中的变量被声明为全局时，动态变量引用才被解析为全局（非超级全局）的。（重要提示：这也适用于<code>Gui</code>中的<code>v变量</code> ）。</p>
<p>变量名为空或太长，而导致两层解析失败的，会显示错误消息，并导致线程中止，而不是默默地产生一个空字符串。这使得它们和输入/输出变量更加一致。在变量名称中使用非法字符，过去会导致报错，现在仍然如此。</p>
<p>在函数中声明局部变量，不会使函数中的变量成为默认全局的（即函数的“假设全局模式”）。</p>
<p><code>#MustDeclare [On|Off]</code>启用或禁用“显式声明模式”。如果在库文件中使用，则只影响该库文件，和任何该库文件显式#includes的文件。但是，仍然从主脚本继承了默认设置。它是位置相关的，但不能在函数中使用（由于以下原因）。函数关于假设局部变量或显式声明模式的设置，具体取决于函数定义时的设置，但可以使用不带变量的<code>Global</code> ， <code>Local</code>或<code>Static</code>进行重设置。</p>
<p><code>Var varname</code>声明一个全局变量，但不会使其成为超级全局变量（即默认在所有函数中可见）。只有在启用<code>#MustDeclare</code>时，这些声明才必需。</p>
<h3 id="expressions">表达式</h3>
<p>被双引号括起来的字符串字面量，可以用<code>"双引号"</code>或<code>'单引号'</code>来写，但必须以同类型的引号开始和结束。两者都允许嵌套表达式，例如<code>"明年是%A_Year+1%"</code>字面的引号，要在前面加上转义字符来表示, 像 <code>`"</code> 或 <code>`'</code>, 或者使用另一种引号括起来<code>'"42"是答案'</code> 。连用引号没有特殊意义，并在起连接字符串作用时，会报错——因为缺少空格</p>
<p>操作符<code>&amp;&amp;</code> ， <code>||</code> ， <code>and</code>和<code>or</code>返回决定结果的值，类似JavaScript 及Lua。例如， <code>"" or "default"</code>返回<code>"default"</code> ，而不是返回<code>1</code> 。。若脚本需要纯布尔值（0 或1），可这样<code>!!(x or y)</code>或<code>(x or y) ?1 : 0</code> 。</p>
<p>自动连接字符串中，字符串间必须至少有一个空格或制表符（V1帮助文档说，“应该”有一个空格）。</p>
<p>如<code>x(), y()</code>的多语句表达式，最终返回最右侧的子表达式，而非最左侧的表达式在v1和v2中，子表达式都按照从左到右的顺序被计算。</p>
<p>逗号后的等号，不再表示赋值：像 <code>x:=y, y=z</code>中的<code>y=z</code>是一个无效的比较判断，而不是赋值。</p>
<p><code>:= += -= *= /= ++ --</code>拥有一致的行为，而不论它们是否在单独使用，或同其它操作
符组合使用，比如<code>x := y, y += 2</code> 。举例， <code>x := %y%()</code>中，在动态调用失败时，不再设置x为空字符串。</p>
<p>科学计数法可以不用小数点（但无论如何仍产生浮点数）。</p>
<p>表达式<code>funcName[""]()</code>和<code>funcName.()</code>不再使用函数名称调用函数。省略该方法的名称作为<code>.()</code>现在导致加载时错误消息。使用<code>%funcName%()</code>代替。</p>
<p>若<code>var :=</code>右侧无赋值，载入时将报告错误。V1 版本中它等效于<code>var := ""</code>，但当与其他表达式组合时会失败且无提示，如 <code>x :=, y :=</code> 。</p>
<p>当原义字符串后面，跟着模糊的一元/二元操作符，则载入时出错。例如， <code>"x" &amp;y</code>可能表示连接字符串<code>"x"</code>与<code>y</code>的地址 ，但在语法上这是一个无效的按位与运算。</p>
<p>任何情况下，在表达式中的单词<code>new</code>都不再被视为变量。支持复杂的表达式；如<code>new (getClass())(params)</code>或<code>new new {...}(inner_prms)(outer_prms)</code></p>
<p>类变量初始化——在类块内、方法外的赋值语句——不再触发__Set 元函数。</p>
<p><code>word ?x : y</code> ， <code>word ++</code>和<code>word --</code>不再是表达式，因为word可能是用户定义的命令。要使用三元操作符，后置自增或自减操作符，要么省略变量与操作符之间的空格，要么把变量或表达式包裹在圆括号中。</p>
<p>新操作符<code>is</code>取代了<code>if var is type</code> 。由于<em>type</em>是字符串，它必须包含在引号中（或是变量）。支持的变量类型和以前相同，但新增了<code>object</code>和<code>byref</code>类型。此外，对<code>x is y</code> ，当<em>y</em>是对象时，检测<em>x</em>是否派生自<em>y</em>不论直接或间接。</p>
<p>关键词<code>contains</code>和<code>in</code>保留，供将来使用。</p>
<p>取地址操作：由于数字和字符串现在是不同的类型，<code>&amp;(var := 123)</code>现在返回一个64位整数的地址，而不是字符串的地址。为了保持一致性，VarSetCapacity返回6（64位整数的空间再减一个空终止符）。</p>
<p>表达式求值时，字符串长度现在被缓存了。这改善性能，并允许字符串包含二进制零。尤其：</p>
<ul>
<li>两个字符串其中一个或两个包含二进制零的级联不再导致数据的截断。然而，通过将结果MSGBOX或类似最多只能显示到第一二进制零。</li><li>区分大小写的相等运算（ <code>==</code> ）可被用于比较的二进制数据。其他运营商相比，只“看”到第一个二进制0。</li><li>二进制数据可以从函数返回，并分配给对象。然而，随着数据ClipboardAll这样做使其回复到正常串，防止它被还原到剪贴板后（这可能仍然是固定的）。</li></ul>
<p>许多命令和函数仍然以空值作为字符串的结束，因此只会“看”到最多第一个二进制0（后面的看不到）。</p>
<h3 id="objects">对象</h3>
<p>键值的储存方式，不同于1版。在以下几点：</p>
<ul>
<li><p>在V1，引号字符串如果被直接使用，总会认为是非数字的，所以<code>x["1"]</code>和<code>x[a:="1"]</code>是不相等的。这是V1变量类型系统的怪癖，V2修复了这一点。为了简洁起见，下面的解释忽略这个怪癖。</p>
</li><li><p>这不适合在32位整数的关键数据类型中的纯整数版本是截断V1但存储为v2的字符串。这会影响比-2147483648小于或大于2147483647的整数，但仅限于32位版本。</p>
</li><li><p>在V1，整数字符串总是被转换成纯二进制整数，这导致信息量丢失。比如下面的转换，在V1被进行，但在V2，字符串被保留了：</p>
<ul>
<li>“01” →1</li><li>“+2” →2</li><li>“0x3” →3</li><li>"   4   " → 4</li><li>“9999999999999999999”→9223372036854775807（x64）或-1（x86），由于整数键值数据类型的限制。</li></ul>
</li><li><p>从v2.0-a067版本起，当不会引起如上所说的数据丢失时，数字字符串被转换为纯整数。相比之下，v2.0-a048到v2.0-a066，都把数字字符串和纯整数完全区分开。</p>
</li></ul>
<p>当通过对象调用函数时，对象本身会作为第一个参数被传递，无论函数被存储在哪里（在该对象中，或是它的基类中）。在V1中，如果函数就是被存储在该对象里，对象则不会被作为参数传递。</p>
<p>当Fn是一个函数或对象时， <code>%Fn%()</code>调用<code>Fn.Call()</code>，而不是<code>Fn[""]()</code>。函数不再支持匿名方法。</p>
<p>在<code>Fn = this.Method</code> 中，<code>this.Method()</code>会调用<code>Fn.Call(this)</code> ，而不是<code>Fn[this]()</code>。函数对象应该实现一个<em>Call</em>方法，而不是<em>__call</em>元函数。</p>
<p>若x是对象，定义<code>x.base[key]</code>可阻止进行如<code>x[key] := val</code>的赋值时，对<code>x.base.base.__Set()</code>的调用。这是为了保持与__Get 及__Call 的一致。</p>
<p>若<code>__New</code>元方法被定义，当新建对象它却不能被调用（例如__New需要参数，但未被提供）时，<code>new Obj()</code>操作失败。</p>
<p>对象和SafeArrays的所有内置方法，不再支持_（下划线）前缀，除了<code>_NewEnum</code> （因为COM对象的兼容性需要）。对对象来说，<code>ObjNewEnum(x)</code>仍然和<code>x._NewEnum()</code>等价。</p>
<p>方法<code>Insert</code>和<code>Remove</code>已被删除。在v1.1.21版时，它们就被InsertAt, RemoveAt, Push, Pop, Delete和ObjRawSet取代。</p>
<p>在表达式中创建或从一个函数返回的对象现在正在举行，直到表达式计算完成，然后释放。此略微提高性能，并允许在表达式中用于存储器管理的临时对象，而不必担心被过早释放的对象。</p>
<p>对象可以包含其中包含二进制零字符串值（但不是键）。克隆对象保留在字符串中的二进制数据，但不再保留超出数据长度的数据（FIXME：提供一种方式来设置的长度）。</p>
<h3 id="uncategorized">未分类</h3>
<p>当初始化声明变量或可选参数时，须使用<code>:=</code>替代掉<code>=</code>。</p>
<p>允许在<code>If Expression,</code>的逗号后同一行上放置执行语句（命令或表达式）。</p>
<p><code>Return %var%</code>现在表示双层-变量重解析，之前它等效于<code>Return var</code> 。</p>
<p>命令ARG游戏永远不会被默认表情，除了与控制流语句，比如回波。的<code>%</code> （％，其次是空间）前缀仍然可以用于强制表达。</p>
<p>的#include是相对于包含在默认情况下的当前文件的目录。</p>
<p>在一个函数中定义的标签具有本地范围;他们只看到内部的功能，不与其它地方定义标签冲突。定时器和桂子程序可以是局部的，但必须从函数内。</p>
<p><code>For k, v in obj</code>现在的“本地化” K和V。当循环中断或结束，K和V都恢复至环路开始之前所具有的数值。</p>
<p>在表达式中逸出逗号导致它被解释为多语句操作者而不是一个分隔符。这已经是命令的情况下，而不是变量声明。例如， <code>local x:=1, y:=2</code>声明两个变量，但漏出的逗号会导致它被解释为<code>local x:=(1, y:=2)</code>需要注意的是延续部分没有<code>,</code>选择自动跳脱逗号。</p>
<h3 id="continuation-sections">继续装置</h3>
<p>智能LTRIM：默认行为是依靠下面的延续区段选择第一线前导空格或制表符的数量，然后从每行删除，很多空格或制表符。如果第一行混合空格和制表符，仅第一类型的字符被视为缩进。如果任何行比第一行或使用错误的字符缩进少，在该行的所有前导空格被保留原样。</p>
<p>引号（单，双）是由缺省文字;这可以通过禁用<code>Q</code>选项。</p>
<p>换行字符（ <code>`n</code> ）在表达式被视为空格。这允许使用具有默认选项的延续部分（即，省略被写入多线表达式<code>Join</code> ）。</p>
<h3 id="command-">命令（）</h3>
<p>所有命令现在可以称为功能，除了控制流语句，比如回波。翻译规则是：</p>
<ul>
<li>如果该命令的第一个参数是一个输出变量和所述第二参数不是，就变成返回值。否则，RunWait和SendMessage消息返回的ErrorLevel的值，并且其设置在失败和成功0的ErrorLevel返回1中的任何其它命令。ErrorLevel被设置仍照常。</li><li>剩余的输出变量等ByRef参数的处理，不同之处在于，如果被调用的函数不正确则抛出异常。传递空字符串相当于省略了参数，但任何其它的值（其不是可变参考）是不允许的。</li></ul>
<p><strong>不完全的：</strong>作为命令和功能仍然在内部不同，定义具有相同名称的功能作为一个命令目前覆盖命令仅用于调用的功能（）风格;即指挥风格仍然调用原始命令。</p>
<p><strong>实验：</strong>返回，直到，环路，LoopF​​iles，LoopReg，LoopRead和LoopParse还支持表达的语法。也就是说，整个参数列表可以在一对括号来强制表达式为每个参数括起来。然而，这些命令不是功能;例如， <code>x := return(y)</code>是无效的。</p>
<h3 id="function-args-">功能， <em>参数数量</em></h3>
<p>所有的功能现在被称为命令，其中包括尚未手动执行#included库函数。翻译规则目前：</p>
<ul>
<li>输出变量插入函数是否内置或包含“回归”的参数列表的开头。（不包括没有比其他返回值来表示成功/失败新的内置功能）。</li><li>所有参数支持<code>%</code>为强制的表达式。</li><li>ByRef参数的被处理像输入/输出变量，但也允许表达式。 <code>% var := "value"</code>将初始化<em>var</em>和通过它的ByRef给该函数。</li><li>的内置函数OutputVar中参数被当作命令的输出瓦尔;没有文字或表达式。</li><li>所有其他参数默认为正常的文本模式。这包括DllCall，NumGet和NumPut的所有参数。传递变量引用，使用<code>% var</code>或<code>%var%</code></li><li>文字逗号必须始终逃脱，甚至在函数的最后一个参数。这可能会改变，因为它是目前内置命令不一致。</li></ul>
<p>方法也可以叫做，具有以下用途：</p>
<ul>
<li>在作为命令名，写入由点分离的目标对象和方法名。<code>无功。Method</code>和<code>Var.属性。Method</code>都是可以接受的，但任何更复杂的（例如<code>Var[x].Method</code>或<code>%Var%.Method</code>不支持）。</li><li>返回值总是丢弃;没有输出变量。</li><li>所有ARG游戏默认的文本。</li></ul>
<h3 id="types">类型</h3>
<p>一般来说，V2产生具有依赖于一个值的类型的任何代码更一致的结果。</p>
<p>在V1，可变可以同时包含一个字符串和一个高速缓存的二进制数，每当变量被用作一个数被更新。由于此缓存二进制数是检测的值的类型的唯一手段，通过缓存像表达式内部执行<code>var+1</code>或<code>abs(var)</code>有效地改变了的“类型” <code>var</code>作为副作用。 V2禁用此缓存，以便<code>str := "123"</code>始终是一个字符串， <code>int := 123</code>总是整数。因此， <code>str</code>需要在每次它被用作一个数（而不是仅在第一时间）的时间来进行转换。</p>
<p>内置的“变量” <code>true</code> ， <code>false</code> ， <code>A_PtrSize</code> ， <code>A_IsUnicode</code> ， <code>A_Index</code>和<code>A_EventInfo</code>总是返回纯整数，而不是字符串。他们有时会返回字符串V1由于已在V2被取代某些优化。</p>
<p>所有文字数字被转换成纯二进制数在加载时和它们的字符串表示被丢弃。例如， <code>MsgBox % 0x1</code>等同于<code>MsgBox 1</code> ，而<code>MsgBox % 1.0000</code>相当于<code>MsgBox 1.0</code> （因为默认浮子格式已改变）。在一个变量中存储多个或从UDF返回保持其纯数值状态。</p>
<p>通过引用文字字符串连接生产引述文字字符串和字符串不再无条件地视为非数字。相反，他们将被视为相同存储在变量或者从函数返回的字符串。这有以下含义：</p>
<ul>
<li>引用文字<code>"0"</code>被认为是假的。</li><li><code>("0xA") + 1</code>和<code>("0x" Chr(65)) + 1</code>产生11代替失败。</li><li><code>x[y:="0"]</code>和<code>x["0"]</code>现在具有相同的行为。</li></ul>
<p>的对象解释不同类型的密钥的方式发生了变化。请参阅<a href="#objects"><em>对象</em></a>本文档的细节部分。</p>
<p>关系运算符，如=，&lt;和&gt; =稍有不同。如果两个操作数都是数字和至少一个操作数是<em>纯的</em> ，它们在数值相比较。否则，他们是按字母顺序进行比较。因此，例如，54和“530”进行数值比较，而“54”和“530”是按字母顺序比较。此外，存储在字符串变量从文字字符串处理没有区别。</p>
<p><code>Type(Value)</code>返回以下字符串之一：字符串，整数，浮点数，对象或特定类的内置对象类型，如文件对象或ComObject。</p>
<h2 id="library">图书馆</h2>
<p>删除命令：</p>
<ul>
<li>ASC（）（使用奥德（））</li><li>自动微调（使用TRIM（））</li><li>ComObjMissing（）（写两个连续的逗号，而不是）</li><li>ComObjUnwrap（）（使用ComObjValue（）来代替，如果需要ObjAddRef（））</li><li>ComObjEnwrap（）（使用ComObject（）代替，并ObjAddRef（）如果需要的话）</li><li>ComObjXXX（）其中XXX比的明确定义ComObj功能之一的任何其他（使用ComObjActive（）或ComObject（）代替）。</li><li>EnvDiv</li><li>EnvMult</li><li>EnvUpdate（这是非常有限的有用性，并且可以用一个简单的SendMessage代替）</li><li>FileReadLine（使用文件读取循环或的FileOpen）</li><li>IfXXX（修改MSGBOX作出IfMsgBox过时）</li><li>如果之间的/是/在/载</li><li>进展（使用GUI）</li><li>SetBatchLines（-1现在是默认行为）</li><li>SETENV</li><li>SetFormat（格式（）可以用于格式的字符串）</li><li>SoundGetWaveVolume / SoundSetWaveVolume（稍有不同的行为SoundGet / SoundSet关于平衡，但没有一个保持平衡）</li><li>SplashImage（使用GUI）</li><li>SplashTextOn /关（使用GUI）</li><li>StringGetPos（使用InStr函数）</li><li>StringLeft<br>StringLen<br>StringMid<br>StringRight<br>StringTrimLeft<br>StringTrimRight  - 请使用SubStr代替这些命令。</li><li>StringReplace（使用StrReplace代替）</li><li>StringSplit（使用StrSplit代替）</li><li>变换（DEREF子命令现在是一个单独的命令）</li><li>WinGetActiveStats</li><li>WinGetActiveTitle</li><li>#CommentFlag</li><li>#Delimiter</li><li>#DerefChar</li><li>#EscapeChar</li><li>#LTrim</li><li>#MaxMem</li><li>#NoEnv（现在的默认行为）</li></ul>
<p>重命名的命令：</p>
<ul>
<li>ComObjParameter（） - &gt; ComObject（）</li><li>DriveSpaceFree  - &gt; DriveGet子命令SpaceFree</li><li>EnvAdd  - &gt;使用DateAdd（）</li><li>EnvSub  - &gt;则DateDiff（）</li><li>FileCopyDir  - &gt; DirCopy</li><li>FileCreateDir  - &gt; DirCreate</li><li>FileMoveDir  - &gt; DirMove</li><li>FileRemoveDir  - &gt; DirDelete</li><li>FileSelectFile  - &gt; FileSelect</li><li>FileSelectFolder  - &gt; DirSelect</li><li>StringLower  - &gt; StrLower（修改）</li><li>StringUpper  - &gt; StrUpper（修改）</li><li>变换DEREF  - &gt; DEREF</li><li>UrlDownloadToFile  - &gt;下载</li><li>WinMenuSelectItem  - &gt; MenuSelect</li></ul>
<p>除去无证AutoIt2命令（在v1.1.09也被除去）：</p>
<ul>
<li>HideAutoItWin</li><li>LeftClick</li><li>LeftClickDrag</li><li>重复/ EndRepeat</li><li>右键点击</li><li>RightClickDrag</li></ul>
<h3 id="modified-commands-functions">修改命令/功能</h3>
<p><code>Chr(0)</code>返回长度为1的串，包含二进制零。这是对串二进制零提高支持的结果。</p>
<p><code>ComObject(pdsp)</code> <code>ComObject(9, pdsp)</code>和<code>ComObject(13, pdsp)</code>不再调用的AddRef默认;他们默认为指针的“取得所有权”。其中使用最多的v1脚本<code>ComObjEnwrap(pdsp)</code>谷歌搜索结果的前几页之内）使用它不正确;也就是说，它们并没有释放自己指针的副本。对于V2，该脚本必须调用<code>ObjAddRef(pdsp)</code>之前<code>ComObject(pdsp)</code>如果没有“自己的”参考（即，因为指针会自动释放，既可以当包装对象被释放或立即作为一个副作用内ComObject查询的IDispatch（））。<em>flags</em>参数现在只影响SAFEARRAYS。</p>
<p>ControlMove，ControlGetPos和ControlClick现在使用的客户端坐标（如GuiControl），而不是窗口坐标。客户端坐标是相对于客户区，不包括窗口的标题栏和边框的左上角。（控制只对客户端区域内呈现。）</p>
<p>DllCall：黄芪甲甙现在只输入。由于缓冲区永远只能作为输入字符串的大，这是从来没有的输出参数有用。这适用于WSTR代替ASTR如果编译为ANSI（但v2是目前仅Unicode）。</p>
<p>DriveGet有一个无证的子命令设置在硬盘标签。这已被删除。使用<code>Drive, Label</code>代替。</p>
<p>的FileOpen使最终的行翻译默认;使用<code>*</code>选项字符禁用此。</p>
<p>FileSetAttrib和FileSetTime：在OperateOnFolders？和递归？参数已经被替换为一个模式参数等同于循环文件的命令。例如， <code>FileSetAttrib, +a, *.zip, RF</code> （递归上的文件仅操作）。</p>
<p><code>文件。ReadLine()</code>不再包括在返回值结束行。</p>
<p><code>Func(Fn)</code>返回一个空字符串（而不是0）如果该功能不存在，并返回<em>FN</em>本身，如果它是一个函数的参考，而不是0。</p>
<p>函数GetKeyState现在只有一个功能，而不是一个命令。该函数总是返回0或1，即使当使用命令语法调用。</p>
<p>GroupAdd命令：删除标签参数和相关功能。这是当GroupActivate未能找到任何匹配窗口，以检测不直观的方式;的ErrorLevel应改为使用。</p>
<p><code>Hotkey</code>不再默认使用脚本的最底部<code>#If</code> / <code>#IfWin</code> 。热键/热字串线程默认的相同的标准作为热键，所以<code>Hotkey, %A_ThisHotkey%, Off</code>关闭，即使它是上下文敏感的当前热键。所有其他线程默认被自动执行部分，它本身默认为无标准（全局热键）一次使用的设置。</p>
<p><code>Hotkey</code>现在总是给予特别待遇为以下值，从不把它们当作标签/函数名称： <code>On</code> ， <code>Off</code> ， <code>Toggle</code> ， <code>AltTab</code> ， <code>ShiftAltTab</code> ， <code>AltTabAndMenu</code> ， <code>AltTabMenuDismiss</code> 。旧的行为是使用，如果它存在的标签/功能，但只有当<em>标签</em>参数不包含变量引用或表达式。</p>
<p><code>Hotkey, If</code>现在可以识别其使用的表达<code>and</code>或<code>or</code>运营商。因为这些经营者与替代这并不在V1工作<code>&amp;&amp;</code>或<code>||</code>在加载时。</p>
<p><code>Hotkey, If..</code>是永远不落的ErrorLevel。抛出一个异常失败。</p>
<p>IniRead默认为省略了<em>默认</em>参数时一个空字符串，而不是字<code>ERROR</code> 。此外，ErrorLevel被如果发生错误设定。</p>
<p>输入现在总是返回结束键AZ在较低的情况下，与其他人物一致（非美国键盘布局）。</p>
<p>的InputBox已被赋予了语法检修，使其更容易使用（用较少参数）。见<a href="#inputbox">的InputBox</a>供使用。</p>
<p>InStr函数的参数<em>CASESENSITIVE</em>现在根据通常的规则布尔评估。在V1，非数字值转换成<code>0</code> ，这是<em>错误的</em> 。在V2，比其他非数字值<code>""</code>被认为是<em>真实的</em> 。</p>
<p>MSGBOX有它的语法变为优先考虑其最常用的参数，提高了易用性。“智能”逗号操作已被删除;也就是说，它现在处理逗号一样的其他功能。见<a href="#msgbox">MSGBOX</a>的使用。</p>
<p>NumPut / NumGet：如果含有纯数字的变量被传递给<code>VarOrAddress</code>参数，变量的值而不是使用变量本身的地址。</p>
<p><code>Object()</code>和<code>{}</code>不再导致<code>__Set</code>被调用用于每个键-值对。<code>Object(obj)</code>不再调用AddRef和返回对象的地址。如果需要，使用<code>ObjAddRef(addr := &amp;obj)</code>代替。</p>
<p><code>OnExit</code> （命令）已被移除;使用将其在v1.1.20加入代替的OnExit（）函数。A_ExitReason也被删除;其值可作为的OnExit回调函数的参数。</p>
<p><code>OnClipboardChange:</code>标签）不再自动如果存在的话叫。使用这是在v1.1.20加入，而不是OnClipboardChange（）函数。</p>
<p>的onMessage已更改为治疗功能名称是函数引用是v1.1.20同样的方式对待。也就是说， <code>OnMessage(x, "MyFunc")</code>寄存器MYFUNC用于信息x，同时仍然允许其它功能来监控信息x。该函数必须使用被注销<code>OnMessage(x, "MyFunc", 0)</code>不<code>OnMessage(x, "")</code>也就是现在的误差。<code>OnMessage(x)</code>现在也出现错误。如果失败，的onMessage抛出异常。</p>
<p>PixelSearch和PixelGetColor使用RGB值而不是BGR，用于与其它命令的一致性。</p>
<p>REGEXMATCH选项O和P中除去; O（对象）模式现在是强制性的。</p>
<p>注册命令（RegRead，的RegWrite，RegDelete）：新的语法v1.1.21添加+是现在唯一的语法。根键和子组合。取而代之的<code>RootKey, Key</code> ，写<code>RootKey\Key</code> 。要连接到远程注册表，使用<code>\\ComputerName\RootKey\Key</code> ，而不是<code>\\ComputerName:RootKey, Key</code> 。</p>
<p>RegDelete一个空白或省略<em>ValueName的</em>现在删除密钥的缺省值，对于的RegWrite，RegRead和A_LoopRegName一致性。钥匙可以用新RegDeleteKey命令删除。</p>
<p>RegRead有一个未记录的5-参数模式，其中被输出变量之后指定的值的类型。这已被删除。</p>
<p>SendMessage函数会将ERRORLEVEL设置为<code>ERROR</code> ，而不是<code>FAIL</code>的时候失败了，与运行的一致性。</p>
<p>排序：所述<em>的VarName</em>参数已被分成单独的输入/输出参数，为的灵活性。用法是现在<code>Sort, OutputVar, InputText [, Options]</code>或<code>Output := Sort(Input [, Options])</code></p>
<p>StrGet：如果<em>长度</em>为负，其绝对值表示字符的确切数字转换，包括字符串可能包含任何二进制零-换句话说，结果总是正是长度的字符串。如果<em>Length</em>是正的，转换后的字符串在第一二进制0作为V1结束。</p>
<p>SysGet现在只有数字的子命令;它的其他子命令已经被分成功能。见<a href="#sub-commands">子命令</a>的详细信息。</p>
<p>TrayTip的使用率已更改为<code>TrayTip [, Text, Title, Options]</code> 。<em>选项</em>是由空格或制表符分隔零个或多个不区分大小写选项的字符串。选项有<code>Iconx</code> ， <code>Icon!</code> ， <code>Iconi</code> ， <code>Mute</code>和/或任何的数值如前。TrayTip现在显示即使省略<em>文本</em> （也就是现在更难意外比V1做）。<em>seconds</em>参数不长的情况下（这对Windows Vista或更高版本没有影响）。</p>
<p>WinMove不再有文字字特殊处理<code>DEFAULT</code> 。省略该参数或指定一个空字符串，而不是（这个工作在两个v1和v2）。</p>
<p><strong>未排序：</strong></p>
<p>对于InStr函数，SUBSTR REGEXMATCH和REGEXREPLACE负<em>StartingPos</em>被解释为从端部的位置，从1开始。位置-1是最右边的字符（在V1这是位置0），位置0是无效的。</p>
<p>Loop Parse，SplitPath，StrUpper，StrLower和StrReplace现在接受字面的文本输入，而不是变量，所以要传入一个变量，请使用<code>%InputVar%</code>或<code>% InputVar</code> 。“输入变量”这个概念，对于任何命令都不存在了。</p>
<p>命令接受其开/关/切换现在还接受1/0 / -1（这是更方便的在expresssion）。</p>
<p>下面的命令/函数返回一个HWND作为纯整数而不是作为十六进制字符串：</p>
<ul>
<li>WinActive</li><li>WinExist</li><li>WinGetID</li><li>WinGetIDLast</li><li>WinGetList</li><li>WinGetStyle</li><li>WinGetStyleEx</li><li>WinGetControlsHwnd</li><li>ControlGet HWND</li><li>桂+ HwndVarname</li><li>GuiControlGet命令HWND</li><li>桂添加，...，+ HwndVarname</li><li>MouseGetPos</li></ul>
<p><code>A_ScriptHwnd</code>返回一个字符串，由于技术限制，但在小数更加一致。</p>
<h4 id="loop-sub-commands">环子命令</h4>
<p>删除：</p>
<pre><code>环路，FilePattern [，IncludeFolders？递归？]环路，RootKey [，钥匙，IncludeSubkeys？递归？]
</code></pre><p>使用以下（在v1.1.21增加），而不是：</p>
<pre><code>循环，文件，FilePattern [，模式]环路，注册，RootKey \键[，模式]</code></pre><p>此外，循环解析现在接受正常的字符串，而不是一个InputVar。</p>
<pre><code>环，解析，InputString [，分隔符，OmitChars]</code></pre><p>目前，紧凑的外形（LoopF​​iles，LoopReg，LoopRead和LoopParse）也支持，但是这可能会被删除。（如果你珍惜它，说出来。）</p>
<p>：表达式语法可以通过像一个函数调用写入循环命令中使用<code>LoopRead(inputFile, outputFile)</code>OTB支持这个语法。目前还不能是“循环”，并且由于不确定性的子命令名之间的空间。</p>
<h4 id="inputbox">的InputBox</h4>
<p>的InputBox，OutputVar中[，文字，标题， <strong>选项</strong> ，默认]</p>
<p>选项参数接受的由空格或标签，类似于桂控制选项分隔零个或多个不区分大小写选项的字符串。例如，这包括所有支持的选项： <code>x0 y0 w100 h100 T10.0 Password*</code> 。<code>T</code>是超时和<code>Password</code>具有相同的用法相当于编辑控制选项。</p>
<h4 id="msgbox">MSGBOX</h4>
<p>MSGBOX [，文字，标题，选项，OutputVar中]<br>结果：= MSGBOX（[文本，标题，选项，OutputVar中]）</p>
<p>选项参数接受的由空格或标签，类似于桂控制选项分隔零个或多个不区分大小写选项的字符串。</p>
<ul>
<li><code>Iconx</code> ， <code>Icon?</code> ， <code>Icon!</code> 并且<code>Iconi</code>设置图标。</li><li><code>Default</code>立即通过一个整数，其后将第<em>n</em>个按钮作为默认值。</li><li><code>T</code>紧跟一个整数或浮点数设置超时，以秒。</li><li><code>Owner</code>紧跟一个HWND设置所有者，覆盖<code>Gui +OwnDialogs</code> 。</li><li>以下操作之一互斥串的设置按钮选择： <code>OK</code> ， <code>OKCancel</code> ， <code>AbortRetryIgnore</code> ， <code>YesNoCancel</code> ， <code>YesNo</code> ， <code>RetryCancel</code> ， <code>CancelTryAgainContinue</code>由斜线（分离，或者只是缩写<code>o/c</code> ， <code>y/n</code>等），或者仅仅是声母没有斜杠。</li><li>任何数值，一样V1。数字值可以用字符串选项组合使用，或选项可以是纯的整数。</li></ul>
<p>返回值，这也是存储在OutputVar中，是按钮的名称，没有空格。这些都是在V1使用与IfMsgBox是相同的字符串。</p>
<p>OutputVar中被提供以允许使用命令语法的（具有比行其它按钮），同时仍允许最常用的参数（文本）是第一个参数。需要注意的是OutputVar中是完全没用的省略选项时。</p>
<h4 id="sub-commands">子命令</h4>
<p>温格特，万迪诺和过程的子命令已被替换为单个功能，并且主命令已被删除。排除废弃命令/属性参数，使用的是相同，除了下面的子命令之前：</p>
<ul>
<li>万迪诺启用/禁用 - &gt; WinSetEnabled开/关/切换/ 1/0，WinTitle等</li><li>万迪诺顶部/底部 - &gt; WinMoveTop / WinMoveBottom，WinTitle，等等。</li><li>万迪诺重绘 - &gt; WinRedraw，WinTitle，等等。</li><li>处理优先级 - &gt; ProcessSetPriority，优先级，PID或 - 名称</li><li>ProcessExist，ProcessClose，ProcessWait和ProcessWaitClose目前都返回PID，命令语法使用时（这可能会改变）具有OutputVar中，并没有设置的ErrorLevel。</li><li>万迪诺朵蒙特和跨被拆除。使用WinSetAlwaysOnTop和WinSetTransparent代替。</li><li>温格特ControlList  - &gt; WinGetControls（返回一个数组）。</li><li>温格特ControlListHwnd  - &gt; WinGetControlsHwnd（返回一个数组）。</li><li>温格特列表 - &gt; WinGetList（返回一个数组）。</li></ul>
<p>当使用函数的语法调用，所有万迪诺”功能成功在失败时返回1，0，同时ErrorLevel被设置为0成功，1失败。</p>
<p>以下功能以前是SysGet的子命令：</p>
<pre><code>存在：= MonitorGet（N，左，上，右，下）存在：= MonitorGetWorkArea（N，左，上，右，下）计数：= MonitorGetCount（）初级：= MonitorGetPrimary（）名称：= MonitorGetName（N）</code></pre><h3 id="new-commands-functions">新命令/功能</h3>
<p><code>DirExist(Path)</code> ，类似于FileExist使用。</p>
<p><code>RegDeleteKey, RootKey\SubKey</code>删除注册表项。（RegDelete现在仅删除值，在一个注册表循环省略所有参数时除外。）</p>
<h3 id="built-in-variables">内置变量</h3>
<p>A_OSVersion始终返回格式的字符串<code>major.minor.build</code> ，如<code>6.1.7601</code>的Windows 7 SP1。因为只有基于NT的系统支持A_OSType已被删除。</p>
<p>改名为：</p>
<ul>
<li>A_LoopF​​ileFullPath  - &gt; A_LoopF​​ilePath（如果循环的参数是相对收益的相对路径，所以“全路径”被误导）</li><li>A_LoopF​​ileLongPath  - &gt; A_LoopF​​ileFullPath</li><li>COMSPEC  - &gt; A_ComSpec</li></ul>
<p>删除：</p>
<ul>
<li>PROGRAMFILES（使用A_ProgramFiles）</li><li>A_AutoTrim</li><li>A_BatchLines</li><li>A_ExitReason</li><li>A_FormatFloat</li><li>A_FormatInteger</li></ul>
<p>添加：</p>
<ul>
<li>A_InitialWorkingDir（见<a href="#default-settings">默认设置</a> ）</li></ul>
<p>以下内置变量可以分配值：</p>
<ul>
<li>A_ControlDelay</li><li>A_CoordMode ..</li><li>A_DefaultMouseSpeed</li><li>A_DetectHiddenText</li><li>A_DetectHiddenWindows</li><li>A_EventInfo</li><li>A_FileEncoding</li><li>A_Index：对于循环计数，修改这会影响很多迭代是如何进行的。</li><li>A_KeyDelay</li><li>A_KeyDelayPlay</li><li>A_KeyDuration</li><li>A_KeyDurationPlay</li><li>A_MouseDelay</li><li>A_MouseDelayPlay</li><li>A_LastError：调用Win32 SetLastError（）函数。</li><li>A_MouseDelay</li><li>A_RegView</li><li>A_ScriptName：更改默认对话框标题。</li><li>A_SendLevel</li><li>A_SendMode</li><li>A_StoreCapslockMode</li><li>A_StringCaseSense</li><li>A_TitleMatchMode</li><li>A_TitleMatchModeSpeed</li><li>A_WinDelay</li><li>A_WorkingDir：与调用SetWorkingDir。</li></ul>
<h2 id="error-handling">错误处理</h2>
<h3 id="expressions">表达式</h3>
<p>当下列任何故障的发生（而不是忽略失败），则抛出异常：</p>
<ul>
<li>未能为内置函数的返回值，串联或表达式的结果分配内存。</li><li>堆栈下溢（典型地通过一个语法错误引起的）。</li><li>试图分配到的东西是不变量（或数组元素）。</li><li>尝试赋值给一个只读变量。</li><li>试图双DEREF具有空名称，如<code>fn(%empty%)</code></li><li>未能执行动态函数调用或方法调用。</li><li><code>x[y,z]</code>由于失败<code>x[y]</code>含有非对象值。</li><li>因为目标是不是一个对象，或者该方法/属性没有被处理的调用失败。关联数组，只有一个方法调用可导致此。</li><li>一个对象赋值失败，因为内存分配失败。</li><li>可能是不可能的：尝试分配超过200个临时字符串或对象引用（ <em>以</em>每函数调用<em>最多</em>一个分配，对象操作，串联或表达式的结果）。不包括所有分配。在V1限为100个这样的字符串（对象引用未计数）。</li></ul>
<p>一些上述条件在V1检测到，但不中期表达;例如， <code>A_AhkPath := x</code>是在V1但检测到<code>y := x, A_AhkPath := x</code>仅在v2中检测到。</p>
<p>运营商<code>+=</code> ， <code>-=</code> ， <code>--</code>和<code>++</code>治疗空变量为0（为<code>+=</code>和<code>-=</code> ，这仅适用于左手侧）。在V1，这是真的只适用于独立使用的运营商，采用中等表达或与多语句逗号不是时候。</p>
<h3 id="commands">命令</h3>
<p>命令一般使用的ErrorLevel报告故障，有时抛出一个异常（例如无效参数）。这类似于V1，虽然行为在某些特定情况发生了变化。然而，在try块不再包装命令影响此行为，所以行为的可预测性。</p>
<p>命令和内置函数抛出一个异常，当检测到无效的参数（但没有探测到所有无效参数），或者当内存分配失败。</p>
<p>DllCall抛出异常，而不是设置的ErrorLevel。</p>
<p>REGEXMATCH和REGEXREPLACE从未设置的ErrorLevel，而不是抛出一个异常，如果有一个错误。这包括在正则表达式模式和PCRE执行错误语法错误。</p>
<p>电视/ LV / SB功能抛出一个异常，如果默认的GUI不存在或者没有TreeView控件/的ListView /状态栏控制。</p>
<p>数学函数返回空字符串<code>""</code>如果他们的任何输入都非数字，或如果操作是无效的（如被零除）。</p>
<h2 id="other">其他</h2>
<p>命令行参数都存储在一个数组，并分配到超全局变量<code>A_Args</code>代替编号的全局变量的伪阵列。如果无参数传递给脚本， <code>A_Args</code>包含一个空数组。表达<code>A_Args.Length()</code>返回指定参数和数量<code>A_Args[1]</code>返回第一个参数。</p>
<p>如鼠标驱动程序，而不是由120除以报告鼠标滚轮热键设置A_EventInfo到轮增量。一般来说它是120的整数倍，但有些鼠标硬件/驱动器可以在更高的分辨率报告轮运动。</p>
<p>的ErrorLevel可以安全地被分配一个对象而它的风险时，线程被中断丢失。在V1，的ErrorLevel的线程特定性质被保存之前线程的ErrorLevel作为字符串当一个新的线程启动，当新的线程终止恢复其执行。</p>
<p>ErrorLevel被重置为0每个新的线程。在V1，它保留从以前的线程，这也是同样的价值将被重置为在新线程完成值。</p>
<p>FileSelectFile有两个多选择模式，经由选项4和M.选项4和相应的模式已被删除可访问的;他们被无证一段时间。</p>
<p>正则表达式匹配的换行默认为（* ANYCRLF）和（* BSR_ANYCRLF）; `r和`n的除了`r`n的认可。该`一个选项隐启用（* BSR_UNICODE）。</p>
<h3 id="gui">桂</h3>
<p>进展GUI控件不再有默认的PBS_SMOOTH风格，所以现在他们是根据（在Vista / 7例如露娜在XP或航空）系统的视觉风格样式。</p>
<p>GuiSize和GuiDropFiles标签不再设置的ErrorLevel。使用A_EventInfo代替。</p>
<h3 id="persistence">坚持</h3>
<p>脚本是“老大难”，而以下条件中的至少一个满足：</p>
<ul>
<li>至少有一个热键或热字串已被脚本中定义。</li><li>至少一个消息的显示器是有源（通过的onMessage安装）。</li><li>至少有一个GUI是可见的。</li><li>至少有一个脚本定时器当前已启用。</li><li>至少有一个OnClipboardChange回调函数已设置。</li><li>托盘图标可见其菜单定制项目。</li><li>使用#Persistent。</li></ul>
<p>如果最后脚本线程结束或GUI被关闭或摧毁，没有上述条件得到满足，脚本终止。</p>
<p>相比之下，V1脚本是“老大难”时，以下至少有一个为真：</p>
<ul>
<li>至少有一个热键或热字串已被脚本中定义。</li><li>桂或的onMessage（）在脚本的任何地方出现。</li><li>键盘钩子或鼠标钩子安装。</li><li>输入被调用。</li><li>使用#Persistent。</li></ul>
<h3 id="default-settings">默认设置</h3>
<ul>
<li>#NoEnv已被移除;使用EnvGet，而是如果等效内置变量不可用。</li><li>SENDMODE默认输入，而不是事件。</li><li>标题模式默认匹配到2而不是1。</li><li>SetBatchLines已被删除，所以所有的脚本全速运行（相当于SetBatchLines -1 V1）。</li><li>工作目录默认为<code>A_ScriptDir</code> 。 <code>A_InitialWorkingDir</code>包含这是由它推出的AutoHotkey的过程中设置的工作目录。</li><li>#SingleInstance提示行为是默认为所有脚本; #SingleInstance自身激活强制模式。</li><li>ListLines关闭</li><li>CoordMode默认为客户端（在v1.1.05加入）代替窗口。</li></ul>


 
</body></html>